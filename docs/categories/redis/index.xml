<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Redis on 凌桓&#39;s BLOG</title>
        <link>https://blog.orekilee.top/categories/redis/</link>
        <description>Recent content in Redis on 凌桓&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language><atom:link href="https://blog.orekilee.top/categories/redis/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Redis 多机服务</title>
        <link>https://blog.orekilee.top/p/redis-%E5%A4%9A%E6%9C%BA%E6%9C%8D%E5%8A%A1/</link>
        <pubDate>Thu, 26 May 2022 15:07:13 +0800</pubDate>
        
        <guid>https://blog.orekilee.top/p/redis-%E5%A4%9A%E6%9C%BA%E6%9C%8D%E5%8A%A1/</guid>
        <description>&lt;h1 id=&#34;redis-多机服务&#34;&gt;Redis 多机服务&lt;/h1&gt;
&lt;h2 id=&#34;主从同步复制&#34;&gt;主从同步(复制）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主从同步是Redis高可用服务的基石&lt;/strong&gt;，其将&lt;strong&gt;主要存储数据&lt;/strong&gt;的服务器成为&lt;strong&gt;主服务器(master)&lt;/strong&gt;，把对主服务器进行&lt;strong&gt;复制&lt;/strong&gt;的服务器成为&lt;strong&gt;从服务器(slave)&lt;/strong&gt;。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis93.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
并且从节点还可以是其他服务器的主节点，并且拥有属于自己的从节点
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis94.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;通过主从模式来进行读写的分离，主服务器进行写操作，然后将数据同步给从服务器，让从服务器来进行读操作，通过这种模式来分摊主服务器的压力。&lt;/p&gt;
&lt;p&gt;Redis的复制功能主要分为&lt;strong&gt;同步(sync)&lt;strong&gt;与&lt;/strong&gt;命令传播(command propagate)&lt;/strong&gt; 两个操作&lt;/p&gt;
&lt;h3 id=&#34;同步&#34;&gt;同步&lt;/h3&gt;
&lt;p&gt;同步操作用于将从服务器的数据库状态更新至主服务器当前的数据库状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis95.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
在从服务器对主服务器进行复制之前，需要先将从服务器的数据库状态更新至主服务器的服务器状态&lt;/p&gt;
&lt;h3 id=&#34;命令传播&#34;&gt;命令传播&lt;/h3&gt;
&lt;p&gt;命令传播操作用于在主服务器的数据库状态发生变化(执行写命令)，导致主从服务器的数据库状态不一致时，让主从服务器的数据库重新回到一致状态。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis96.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
当客户端对主服务器进行写操作后，此时主从服务器的数据库状态就会不一致。&lt;/p&gt;
&lt;p&gt;为了能够再次让主从服务器的数据库状态恢复一致，此时主服务器会将同一命令发送给从服务器，当从服务器执行完改命令时，数据库状态再次恢复一致。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis97.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;优缺点&#34;&gt;优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能方面：可以实现读写的分离，由主服务器来进行写操作，并将写的结果同步至从服务器，由从服务器来进行读操作，这样就能将压力分摊到各个服务器上&lt;/li&gt;
&lt;li&gt;高可用：当主服务器宕机之后，可以通过故障转移机制将从节点提升为主节点，快速的进行服务器的宕机恢复。&lt;/li&gt;
&lt;li&gt;防止数据丢失：当主服务器的磁盘损坏或者数据丢失后，因为从服务器还保留相关的数据，不至于导致数据全部丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于主从同步需要人工管理，主节点崩溃后需要人工进行从节点的提升才能恢复Redis的正常使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面可以看到，主从同步并没有一个自动的管理机制，当出现主服务器宕机的情况，需要人工干预来进行恢复，但是如果主从服务器数量庞大，又或是因为高并发导致的大量崩溃，这时需要的时间和难度都是非常大的，于是Redis中又引入了&lt;strong&gt;哨兵模式(Sentinel)&lt;/strong&gt; 来作为解决方案，&lt;strong&gt;将管理由人工转向哨兵，使得Redis具有自动容灾恢复的能力&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;哨兵&#34;&gt;哨兵&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;哨兵是Redis高可用性的解决方案&lt;/strong&gt;，通过一个或者多个哨兵组成的哨兵系统，可以监控任意多个主服务器以及它们的从服务器。当某个被监视的主服务器进入下线状态时，哨兵就会自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器继续处理命令请求&lt;/p&gt;
&lt;p&gt;总结下来就是&lt;strong&gt;哨兵模式可以用来监控主从同步服务器节点，并在主从服务器出现问题的时候实现自动容灾恢复&lt;/strong&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis98.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;下线判断与选举&#34;&gt;下线判断与选举&lt;/h3&gt;
&lt;p&gt;由于一个主服务器可能会同时被多个哨兵进行同时进行监控，所以当一个哨兵&lt;strong&gt;主观&lt;/strong&gt;的将其判定为下线时，为了确保这个主服务器真的下线了，它会向同样监视这一主服务器的其他哨兵进行询问，看看它们是否也认为该服务器下线了，当积累到一定数量的下线判断时，此时就会&lt;strong&gt;客观&lt;/strong&gt;认为主服务器下线，开始进行故障转移。&lt;/p&gt;
&lt;p&gt;但是&lt;strong&gt;故障转移只能由一个哨兵来进行&lt;/strong&gt;，所以此时所有监控该服务器的哨兵会进行协商，选举出一个领头哨兵来进行故障转移。&lt;/p&gt;
&lt;p&gt;每一个哨兵都会向其他哨兵发送一个带有自己运行ID的命令，如果接收到该命令的哨兵还没有进行投票，就会将该ID设置为它的头领ID，并返回一个确认恢复。通过这种方法每一个哨兵都可以直到有多少个人为其投票，并选出一个票数最高的作为头领哨兵&lt;/p&gt;
&lt;h3 id=&#34;故障转移&#34;&gt;故障转移&lt;/h3&gt;
&lt;p&gt;故障转移分为以下三个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在已下线主服务器的从服务器中挑选一个出来作为新的主服务器&lt;/li&gt;
&lt;li&gt;在已下线主服务器的从服务器改为复制新的主服务器&lt;/li&gt;
&lt;li&gt;将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，他就会成为新的主服务器的从服务器
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis99.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis100.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis101.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis102.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis103.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis104.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;集群&#34;&gt;集群&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;集群(Cluster)是Redis多机运行中最完美的方案&lt;/strong&gt; ，它的出现甚至可以让我们抛弃掉主从同步和哨兵来实现Redis多机的运行。&lt;/p&gt;
&lt;p&gt;集群是无代理模式去中心化的运行模式，客户端发送的绝大多数命令会直接交给相关节点执行，大部分情况下请求命令不需要转发，或者仅仅只需要转发一次就能完成请求和响应。所以集群中的单个节点的性能与单机Redis服务器的性能非常接近，并且通过水平拓展能够使得性能进行翻倍，所以集群的性能非常的高
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis105.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;strong&gt;由于主从同步只能有一个主节点，而集群可以拥有无数个主从节点，有着更强大的平行拓展能力&lt;/strong&gt;。
所以在理论情况下，如果水平拓展一倍的主节点，相当于请求处理的性能也提高了一倍，也就是说通过平行拓展N倍的主从节点，就会比单机服务来说性能提升了N倍。&lt;/p&gt;
&lt;h3 id=&#34;握手&#34;&gt;握手&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;每个节点其实就是运行在集群模式下的Redis服务器&lt;/strong&gt;，而这些节点在一开始时都是互相独立的，它们都处于一个只包含自己的集群中，要组建一个真正可以工作的集群，我们就必须要将各个独立的节点通过&lt;strong&gt;握手&lt;/strong&gt;的方式连接起来。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis106.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis107.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis108.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis109.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis110.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;分片&#34;&gt;分片&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;集群通过分片的方式来保存数据库中的键值对。&lt;/strong&gt;
集群的整个数据库被分为个16384个槽，并且将一个或者多个槽指派给某个节点，让这个节点来负责管理这个槽中的数据以及相关命令，通过这种方法就能很好的进行压力的分摊。&lt;/p&gt;
&lt;p&gt;节点之间会互相转递指派槽的信息
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis111.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis112.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis113.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
对于发送来的命令，会通过其所在的槽来分配至对应的节点，如果分配错误，也会通过转向操作来转交给至正确的节点
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis114.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Redis 事务</title>
        <link>https://blog.orekilee.top/p/redis-%E4%BA%8B%E5%8A%A1/</link>
        <pubDate>Thu, 26 May 2022 15:06:13 +0800</pubDate>
        
        <guid>https://blog.orekilee.top/p/redis-%E4%BA%8B%E5%8A%A1/</guid>
        <description>&lt;h1 id=&#34;redis-事务&#34;&gt;Redis 事务&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_35423154/article/details/108145463&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 事务 ：ACID、并发带来的问题、事务的隔离级别、事务的实现&lt;/a&gt;
在之前的MySQL系列博客中我已经讲过了一些事务的内容，但是Redis与传统的关系型数据库不同，因此下面我会在讲解Redis事务的同时与SQL数据库的事务进行比较。&lt;/p&gt;
&lt;p&gt;为了能帮助大家更好的理解，首先给出Redis事务的所有接口，并结合案例来讲解其具体使用方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MUTLI&lt;/td&gt;
&lt;td&gt;标记一个事务块的开始。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXEC&lt;/td&gt;
&lt;td&gt;执行所有事务块内的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DISCARD&lt;/td&gt;
&lt;td&gt;取消事务，放弃执行事务块内的所有命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WATCH&lt;/td&gt;
&lt;td&gt;监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNWATCH&lt;/td&gt;
&lt;td&gt;取消 WATCH 命令对所有 key 的监视&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;事务的实现&#34;&gt;事务的实现&lt;/h2&gt;
&lt;p&gt;Redis的事务与传统的SQL事务不同，它的本质是&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;一组命令的集合&lt;/strong&gt;， &lt;strong&gt;一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;它的事务主要存在以下三个阶段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;事务开始(multi)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命令入队&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事务执行(exec)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面就结合一个具体案例，来讲解一下它的实现原理&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; MULTI	&lt;span class=&#34;c1&#34;&gt;# 开始事务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET CITY1 &lt;span class=&#34;s2&#34;&gt;&amp;#34;beijing&amp;#34;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;# 插入三个城市&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET CITY2 &lt;span class=&#34;s2&#34;&gt;&amp;#34;shanghai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET CITY3 &lt;span class=&#34;s2&#34;&gt;&amp;#34;shenzhen&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GET CITY2	&lt;span class=&#34;c1&#34;&gt;# 获取城市的名字&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GET CITY3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; EXEC	&lt;span class=&#34;c1&#34;&gt;# 执行事务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;shanghai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;shenzhen&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;事务开始&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们执行&lt;code&gt;MULTI&lt;/code&gt;命令时即代表着事务的开启，此时会将客户端从非事务状态切换到事务状态，通过为客户端状态中的&lt;code&gt;flags&lt;/code&gt;加上&lt;code&gt;REDIS_MULTI&lt;/code&gt;标识实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 打开事务标识&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;client.flags &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; REDIS_MULTI
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;命令入队&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们切换至事务状态后，Redis服务器会根据我们命令来决定执行命令还是将命令放入队列中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果客户端发送的命令是事务相关即&lt;code&gt;EXEC、DISCARD、WATCH、UNWATCH、MULTI&lt;/code&gt;等，服务器会立刻执行命令&lt;/li&gt;
&lt;li&gt;如果客户端发送的是上面以外的命令，这时候服务器就会将命令放入事务队列中，并向客户端返回&lt;code&gt;QUEUED&lt;/code&gt;，告知客户端命令入队&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis86.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis87.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;事务队列&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在客户端的事务状态中维护者一个事务队列，以及队列长度的计数器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiState&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;multiCmd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;commands&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//事务队列，FIFO
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;//命令计数器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiState&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;事务队列其实就是&lt;code&gt;multiCmd&lt;/code&gt;类型的数组，其中每一个&lt;code&gt;multiCmd&lt;/code&gt;节点都包含着每条命令的具体信息，如指向具体实现的命令指针、命令的参数、命令的数量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiCmd&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;//参数的数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisCommand&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//指向具体实现的命令指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiCmd&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;假设此时客户端执行以下命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MULTI&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SET&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Practical Common Lisp&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;QUEUED&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GET&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;QUEUED&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SET&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;author&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Peter Seibel&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;QUEUED&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GET&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;author&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;QUEUED&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时底层的事务队列如下
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis88.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;执行事务&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当客户端向服务器发送&lt;code&gt;EXEC&lt;/code&gt;命令时，服务器会立即遍历客户端的事务队列，按照&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;FIFO(先进先出)&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt; 的顺序执行队列中的所有命令，执行完毕后将命令所得的结果全部返回给客户端
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis89.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;讲完了原理，下面就来讲讲Redis的ACID与传统SQL的有什么不同&lt;/p&gt;
&lt;h2 id=&#34;acid&#34;&gt;ACID&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Redis中，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;单条命令能够保证原子性，但是事务并不能保证原子性&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。下面我分别以编译、运行两个阶段的异常举例，来验证这个结论&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译时异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们来验证编译时异常是否能够保证原子性，我们故意产生语法错误，来验证编译异常时事务是否能够执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; MULTI	&lt;span class=&#34;c1&#34;&gt;#开启事务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK					
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET CITY1 &lt;span class=&#34;s2&#34;&gt;&amp;#34;beijing&amp;#34;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET CITY2 &lt;span class=&#34;s2&#34;&gt;&amp;#34;shanghai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET CITY3	&lt;span class=&#34;c1&#34;&gt;# 故意不给value,使其语法错误&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;error&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; ERR wrong number of arguments &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;set&amp;#39;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;command&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;# 编译报错&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; EXEC	&lt;span class=&#34;c1&#34;&gt;# 执行事务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;error&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; EXECABORT Transaction discarded because of previous errors.	&lt;span class=&#34;c1&#34;&gt;# 事务中存在错误命令，执行失败&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; KEYS *	&lt;span class=&#34;c1&#34;&gt;# 所有命令都没有执行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;empty array&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;从上面可以看到，在编译时异常时Redis是能够保证原子性的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行时异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着来看看运行时异常，我们故意对一个字符串使用计数操作，看看报错后事务是否能够执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; MULTI	&lt;span class=&#34;c1&#34;&gt;# 开启事务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET key1 &lt;span class=&#34;s2&#34;&gt;&amp;#34;HELLO&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 插入一个字符串&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; INCRBY key1 &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;# 对这个字符串+10,必定执行失败&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET key2 &lt;span class=&#34;s2&#34;&gt;&amp;#34;WORLD&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 其他命令&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GET key2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; EXEC	&lt;span class=&#34;c1&#34;&gt;#执行事务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;error&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; ERR value is not an integer or out of range	&lt;span class=&#34;c1&#34;&gt;# 运行错误&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;WORLD&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GET key1	&lt;span class=&#34;c1&#34;&gt;# 其他命令执行成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HELLO&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GET key2	&lt;span class=&#34;c1&#34;&gt;# 其他命令执行成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;WORLD&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;从上面我们可以看到，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;即使事务中有一条命令在执行期间出现了错误，整个事务也会继续执行下去，并且之前执行的命令也不会有任何影响&lt;/strong&gt;。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;总结一下两种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译时异常（代码有问题、命令有错）：事务中所有的命令都不会被执行！&lt;/li&gt;
&lt;li&gt;运行时错误（命令存在语法性错误）：其他命令可以正常执行的，错误命令抛出异常！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也就是Redis事务与传统SQL数据库事务最大的区别，即&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;Redis不支持事务回滚机制(rollback)&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在官方文档中作者是这样描述的，不支持事务回滚的原因是因为这种复杂的功能和Redis追求的简单高效不相符。并且这种运行时错误通常由编程错误产生，通常只会出现在开发环境中，而并不会在生产环境中发生，就没有必要为Redis开发事务回滚功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于以上几点，我们得出结论，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;Redis的事务不能保证原子性&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;：一致性即事务操作前与操作后的状态始终一致&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;隔离性&lt;/strong&gt;：隔离性指的是即使数据库中有多个事务并发执行，各个事务之间也不会互相影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于Redis使用&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;单线程&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;来执行事务以及事务队列中的命令，并且在执行事务的期间不会对事务进行终端，因此Redis的事务总是以&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;串行&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;的方式运行的，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;因此也不存在隔离级别这个概念&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;持久性&lt;/strong&gt;：持久性指的是事务一旦提交，其结果就是永久性的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面也可以看出，除了隔离性以及原子性以外，其余部分都与传统SQL数据库区别不大。&lt;/p&gt;
&lt;h2 id=&#34;watch乐观锁&#34;&gt;WATCH乐观锁&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_35423154/article/details/109259881&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;并发编程中常见的锁机制：乐观锁、悲观锁、CAS、自旋锁、互斥锁、读写锁&lt;/a&gt;
如果不了解乐观锁及其实现原理的小伙伴可以看看我的往期博客，在这里就不再重复，我就简单的说明一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;悲观锁做事比较悲观，它始终认为共享资源在我们使用的时候会被其他线程修改，容易导致线程安全的问题，因此在访问共享数据之前就要先加锁，阻塞其他线程的访问&lt;/li&gt;
&lt;li&gt;乐观锁则于悲观锁相反，它则比较乐观。它始终认为多线程同时修改共享资源的概率较低，所以乐观锁会直接对共享资源进行修改，但是在更新修改结果之前它会验证这段时间有没有其他线程对资源进行修改，如果没有则提交更新，如果有的话则放弃本次操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;WATCH&lt;/code&gt;命令就是一个&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，当它会监视任意数量的key，当执行事务时，如果这些key中有任何一个被修改，服务器都会拒绝执行事务，并向客户端返回事务执行失败的空回复&lt;/p&gt;
&lt;p&gt;下面就结合具体场景来演示一下&lt;/p&gt;
&lt;p&gt;假设此时小明的账户中有1000元，小王的账户有500元，此时小明想转250元给小王
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis90.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET xiaoming &lt;span class=&#34;m&#34;&gt;1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SET xiaowang &lt;span class=&#34;m&#34;&gt;500&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; MULTI
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; DECRBY xiaoming 250	&lt;span class=&#34;c1&#34;&gt;# 转账&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; INCRBY xiaowang &lt;span class=&#34;m&#34;&gt;250&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但是在转账的途中，正好小明花呗的自动还款时间到了，扣费900元，并先他一步提交&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 另外一个线程中，抢先扣费&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; DECRBY xiaoming &lt;span class=&#34;m&#34;&gt;900&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当我们再次执行事务的时候，按道理来说金额不够就应该转账失败，但是此时小明的余额却变成了负数，这就出现了问题，用户可以无限的进行套现，这也就是我们通常所说的事务并发执行的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; EXEC
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; -150
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;750&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为了保证安全，通常我们会使用&lt;code&gt;WATCH&lt;/code&gt;当作乐观锁操作，对key进行监控，当另一个线程修改被监控的key时，就会让事务失败。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; WATCH xiaoming	&lt;span class=&#34;c1&#34;&gt;# 监控小明的账户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; MULTI	&lt;span class=&#34;c1&#34;&gt;# 开启事务，转账&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; DECRBY xiaoming &lt;span class=&#34;m&#34;&gt;250&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QUEUED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; INCRBY xiaowang &lt;span class=&#34;m&#34;&gt;250&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 另一个线程修改小明余额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; DECRBY xiaoming &lt;span class=&#34;m&#34;&gt;900&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 继续运行事务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; EXEC
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;nil&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;# key被修改，事务执行失败&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GET xiaoming	&lt;span class=&#34;c1&#34;&gt;# 可以看到，事务并没有执行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过这种方法，就能够确保我们并发执行事务的安全，当我们确认当前操作不会导致恶劣影响的时候，就可以通过&lt;code&gt;UNWATCH&lt;/code&gt;取消监控，然后&lt;code&gt;WATCH&lt;/code&gt;来获取修改后的新余额来继续监控、执行事务。&lt;/p&gt;
&lt;p&gt;当你看到这里的时候，是不是感觉似曾相识？没错，这就是之前博客中我提到的&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;CAS以及版本号机制&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，也是乐观锁的常见实现方法&lt;/p&gt;
&lt;p&gt;在Redis中，服务器通过一个字典来标记所有正在监控key的客户端
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis91.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
当某一个key被修改时，就会将所有监控它的客户端的&lt;code&gt;REDIS_DIRTY_CAS&lt;/code&gt;标识打开，来标记数据已经被修改，当客户端执行EXEC命令时如果发现标识被修改，则说明此时可能会存在安全问题，于是拒绝执行事务
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis92.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
总结一下就是，我们通过CAS机制判断&lt;code&gt;REDIS_DIRTY_CAS&lt;/code&gt;是否被打开来决定事务的执行，并通过WATCH实现版本号机制以及服务器对客户端的统一管理&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Redis单条命令保证原子性，但是事务不能保证原子性&lt;/li&gt;
&lt;li&gt;Redis事务中没有隔离级别的概念&lt;/li&gt;
&lt;li&gt;Redis事务的本质就是一组命令的集合，命令通过事务队列以FIFO的方式顺序执行&lt;/li&gt;
&lt;li&gt;WATCH命令即乐观锁，服务器通过字典将所有监控客户端与被监控key进行关联，并通过&lt;code&gt;REDIS_DIRTY_CAS&lt;/code&gt;来判断key是否被修改，从而决定是否执行事务&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis 缓存</title>
        <link>https://blog.orekilee.top/p/redis-%E7%BC%93%E5%AD%98/</link>
        <pubDate>Thu, 26 May 2022 15:05:13 +0800</pubDate>
        
        <guid>https://blog.orekilee.top/p/redis-%E7%BC%93%E5%AD%98/</guid>
        <description>&lt;h1 id=&#34;redis-缓存&#34;&gt;Redis 缓存&lt;/h1&gt;
&lt;h2 id=&#34;缓存一致性&#34;&gt;缓存一致性&lt;/h2&gt;
&lt;p&gt;对于缓存和数据库的更新操作，主要分为以下两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先删除缓存，再更新数据库&lt;/li&gt;
&lt;li&gt;先更新数据库，再删除缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;首先可能会带来疑惑的点是，为什么这里是删除缓存而不是更新缓存？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照常理来说，更新的效率通常都会比删除高，因为我们在删除了缓存后当有读操作到来时，当其查询缓存不存在时，就会去查询数据库，并将读取到的值写入到缓存中，这样的效率明显比更新低。&lt;/p&gt;
&lt;p&gt;但是我们还需要考虑一个问题，即&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;缓存的使用率问题&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。如果在短时间内对数据库进行了10000次更新操作，那么缓存也必定会进行10000次的更新操作，那这个缓存它真的有用到那么多次吗？如果它仅仅是一个冷门数据，可能在这期间内只进行了仅仅几次的查询操作，那我们的这些更新操作不是会显得很多余吗？&lt;/p&gt;
&lt;p&gt;所以，我们才会去使用删除。因为在我们删除缓存后，只有在其真正使用到这个数据的时候，才会将其写入缓存，因此我们就不用每次都对缓存进行更新操作，从而保证效率。&lt;/p&gt;
&lt;h3 id=&#34;先删除缓存再更新数据库&#34;&gt;先删除缓存，再更新数据库&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis81.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
对于这种情况，能够保证缓存的一致性吗？&lt;/p&gt;
&lt;p&gt;答案是否定的，例如下面这种场景：
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis82.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程A写入数据，此时先删除缓存&lt;/li&gt;
&lt;li&gt;线程B读取数据，查询缓存不存在，直接去查询数据库&lt;/li&gt;
&lt;li&gt;线程B将查询到的旧值写入至缓存中&lt;/li&gt;
&lt;li&gt;线程A将新数据更新至数据库中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于上述这种情况，线程B在线程A更新数据库之前就提前读取了数据库，从而读取到了旧值，而后线程B将读取到的旧值再次写入缓存中，就出现了缓存不一致的情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那么这个问题如何解决呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时候就需要引入&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;延时双删&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;的机制&lt;/p&gt;
&lt;h4 id=&#34;延时双删&#34;&gt;延时双删&lt;/h4&gt;
&lt;p&gt;为了避免在更新数据库的时候，其他的线程读取到了数据库中的旧值并将其写入缓存这种情况，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;我们会在数据库更新完后等待一段时间，再次删除缓存&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，来保证下一个到来的线程能够将正确的缓存更新回去。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis83.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
流程如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程A写入数据，此时先删除缓存&lt;/li&gt;
&lt;li&gt;线程B读取数据，查询缓存不存在，直接去查询数据库&lt;/li&gt;
&lt;li&gt;线程B将查询到的旧值写入至缓存中&lt;/li&gt;
&lt;li&gt;线程A将新数据更新至数据库中，休眠一段时间&lt;/li&gt;
&lt;li&gt;线程A将缓存再次删除，来确保缓存的一致性&lt;/li&gt;
&lt;li&gt;其他线程查询数据库，将正确的值更新至缓存中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，为了保证我们能够将错误的缓存删除，所以我们的&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;sleep时间只需要大于线程读写缓存的时间&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;即可&lt;/p&gt;
&lt;h3 id=&#34;先更新数据库再删除缓存&#34;&gt;先更新数据库，再删除缓存&lt;/h3&gt;
&lt;p&gt;那么如果我们先更新数据库，再更新缓存呢？
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis84.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
对于这种操作，缓存不一致的情况就更加明显了。由于磁盘I/O速度慢，在更新数据库、删除缓存这段操作之前，其他线程读取到的都是原本缓存中的旧值。甚至可能会由于缓存删除失败(如缓存服务当前不可用的情况)从而导致严重的缓存不一致问题。&lt;/p&gt;
&lt;p&gt;那么如何解决这个问题呢？可以使用以下几种方法&lt;/p&gt;
&lt;h4 id=&#34;修改缓存过期时间&#34;&gt;修改缓存过期时间&lt;/h4&gt;
&lt;p&gt;这是解决这个问题最简单的方法，同时也是治标不治本的方法。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;我们可以将缓存过期时间变短，使其每隔一段时间就会去数据库中加载数据&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，对于更新不频繁的数据来说，就可以很好的解决不一致的问题，但若是更新特别频繁的热点数据，这个方法则失去了作用。&lt;/p&gt;
&lt;p&gt;由于这个方法的适用面小，且实时性和一致性不高，所以我们通常都会选择使用&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;来解决这个问题。&lt;/p&gt;
&lt;h4 id=&#34;消息队列&#34;&gt;消息队列&lt;/h4&gt;
&lt;p&gt;我们可以引入一个&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;来解决这个问题，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;在更新数据库后，我们往消息队列中写入数据，等到消费者从消息队列中取出数据时，再将缓存删除。&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;借助消息队列的&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;消息重试机制&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;来保证我们一定能够成功删除缓存，从而确保缓存的一致性。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis85.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
但是这种方法也存在几个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入消息队列后可能会因为消息的处理导致一定程度的延迟，从而引起短期内的消息不一致&lt;/li&gt;
&lt;li&gt;引入消息队列后导致问题整体复杂化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我们只有在对实时性和一致性要求不高的情况下才会选择这种做法&lt;/p&gt;
&lt;h2 id=&#34;缓存淘汰策略&#34;&gt;缓存淘汰策略&lt;/h2&gt;
&lt;p&gt;redis中缓存的数据是有过期时间的，当缓存数据失效时，redis会删除过期数据以节省内存，那redis是怎样怎样的策略来删除过期数据的呢？&lt;/p&gt;
&lt;h3 id=&#34;过期键删除策略&#34;&gt;过期键删除策略&lt;/h3&gt;
&lt;p&gt;过期删除策略通常有以下三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定时删除&lt;/strong&gt;：在为键设置过期时间的同时创建一个定时器，当过期时间到来时就会触发定时器中的处理函数，立即执行过期键的删除操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定期删除&lt;/strong&gt;：每隔一段时间就对数据库进行一次检查，删除其中的过期键。检查的数据库数量及删除的过期键数量由算法决定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;：不会主动去删除过期键。每次获取键时都会判断获取的键是否过期，如果过期则删除，没过期则返回&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中前两种为&lt;strong&gt;主动&lt;/strong&gt;删除策略，最后一种为&lt;strong&gt;被动&lt;/strong&gt;删除策略。下面就来谈谈这三种策略的优缺点以及Redis中究竟使用的哪一种&lt;/p&gt;
&lt;h4 id=&#34;定时删除&#34;&gt;定时删除&lt;/h4&gt;
&lt;p&gt;定时删除策略对于内存来说十分友好，通过定时器能够保证过期键能够在第一时间被删除，而不会一直占用内存。&lt;/p&gt;
&lt;p&gt;但是同样的，它对CPU时间非常不友好。在过期键比较多的时候，维护大量的定时器会给CPU带来巨大的压力，即使过期键少的时候，它也会将宝贵的CPU时间用在维护定时器，以及删除和当前任务无关的过期键上，对服务器的响应时间与吞吐量造成了一定的影响。&lt;/p&gt;
&lt;h4 id=&#34;惰性删除&#34;&gt;惰性删除&lt;/h4&gt;
&lt;p&gt;从开始的描述可以看出，惰性删除对于CPU时间来说是最为友好的，因为我们只会在取出键的时候才会对其进行删除操作，这也就保证了我们不会在执行其他任务的时候又背地里去删除无关的过期键，合理的利用了CPU时间。&lt;/p&gt;
&lt;p&gt;但是！！！也正是因为这个原因，使得它对内存极度不友好。&lt;strong&gt;如果一个键已经过期，而只要我们不去获取这个键，就不会触发过期检查，那也就意味着他会一直占用这一块内存而不释放&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这意味着什么呢？如果我们有非常多的过期键，而这些过期键又恰好因为版本迭代、项目组交替，在后续版本中并没有对其进行访问，那么它可能&lt;strong&gt;永远&lt;/strong&gt;也不会被删除。我们可以将这种情况当成&lt;strong&gt;内存泄漏&lt;/strong&gt;中的一种，对于Redis这种内存数据库来说，这种情况造成的后果十分严重&lt;/p&gt;
&lt;h4 id=&#34;定期删除&#34;&gt;定期删除&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定期删除策略其实是上述两种策略的折中选择。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定期删除策略相对于定时删除策略来说，由于其每隔一段时间才进行一次删除操作，通过限制了删除操作的时常和频率，大大减少了删除操作对CPU时间的影响。&lt;/p&gt;
&lt;p&gt;相比于惰性删除，并且由于定期删除过期键，有效地减少了过期键带来的空间浪费。即兼顾了CPU，又避免了内存浪费，是两者的折中选择。&lt;/p&gt;
&lt;p&gt;但是上述这些优点的前提，就是我们必须要确定一个&lt;strong&gt;合理的删除操作的时长和频率&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果删除操作过于频繁，则又退化成了定时删除策略，浪费了大量的CPU时间&lt;/li&gt;
&lt;li&gt;如果删除操作执行过少，则又会像惰性删除一样，出现大量的内存浪费问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;redis的选择&#34;&gt;Redis的选择&lt;/h4&gt;
&lt;p&gt;下面给出三种的效率对比&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;CPU：惰性删除 &amp;gt; 定期删除 &amp;gt; 定时删除&lt;/strong&gt;
&lt;strong&gt;内存利用率：定时删除 &amp;gt; 定期删除 &amp;gt; 惰性删除&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;定时删除占用太多CPU时间，影响服务器的吞吐量和性能，但是很好的避免了内存浪费&lt;/li&gt;
&lt;li&gt;惰性删除浪费太多内存，有内存泄漏的风险，但是却保证了CPU的效率&lt;/li&gt;
&lt;li&gt;定期删除属于前两种的折中，既保证了CPU时间的合理利用，又避免了内存的浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为了能够在合理利用CPU时间与避免浪费内存空间之间取得平衡，Redis同时使用了惰性删除和定期删除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样的搭配虽然保证了Redis强大的吞吐量以及响应速度，但是却存在因为没有定时删除机制，所以存在着内存浪费问题。&lt;/p&gt;
&lt;p&gt;由于Redis中通常存储的数据量十分庞大，这就导致了定期删除每次只能抽取其中的一部分进行删除，&lt;strong&gt;倘若有一部分过期键一直没有被抽取到，并且我们也一直没有访问它来触发惰性删除，这个过期键就会一直存在内存中，如果不进行处理，就可能导致内存耗尽。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，Redis又引入了&lt;strong&gt;内存淘汰机制&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;内存淘汰机制&#34;&gt;内存淘汰机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当Redis的内存占用过高时，如果内存不足以容纳新写入的数据，就会通过某种机制来删除一部分键，来减少当前占用的内存，这就是内存淘汰机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前Redis提供了8种内存淘汰策略，除却之前的6种，还有两种Redis4.0后新增的LFU模式：volatile-lfu以及allkeys-lfu&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;volatile-lru&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;已设置过期时间的key中&lt;/code&gt;，挑选&lt;code&gt;最近最少使用&lt;/code&gt;的key淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;volatile-lfu&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;已设置过期时间的key中&lt;/code&gt;，挑选&lt;code&gt;最不经常&lt;/code&gt;使用的key淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;volatile-ttl&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;已设置过期时间的key中&lt;/code&gt;，挑选&lt;code&gt;将要过期&lt;/code&gt;的key淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;volatile-random&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;已设置过期时间的key中&lt;/code&gt;，&lt;code&gt;随机挑选&lt;/code&gt;key淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;allkeys-lru&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;所有key中&lt;/code&gt;，挑选&lt;code&gt;最近最少使用&lt;/code&gt;的key淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;allkeys-lfu&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;所有key中&lt;/code&gt;， 挑选&lt;code&gt;最不经常&lt;/code&gt;使用的key淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;allkeys-random&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;所有key中&lt;/code&gt;，&lt;code&gt;随机挑选&lt;/code&gt;key淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no-eviction&lt;/td&gt;
&lt;td&gt;当内存不足以写入新数据时，&lt;code&gt;写入操作会报错，并且不会淘汰数据&lt;/code&gt;(不常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;乍一看策略很多很难记，其实总共就是四种不同的淘汰策略，以及两种key的选择范围&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择范围&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;allkeys&lt;/strong&gt;：淘汰的范围为所有的key&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile&lt;/strong&gt;：淘汰的范围为已设置过期时间的key&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;淘汰策略&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LRU&lt;/strong&gt;：Least recently used，即淘汰最近最少使用的key&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LFU&lt;/strong&gt;：Least Frequently Used，即淘汰最不经常使用的key&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TTL&lt;/strong&gt;：Time To Live，即淘汰生命时间最短，即将要过期的key&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Random&lt;/strong&gt;：随机淘汰&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中LRU和LFU较为常用，如果有想了解其算法原理的，可以看看我的往期博客
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_35423154/article/details/107876954&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;高级数据结构与算法 | LRU缓存机制（Least Recently Used）&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_35423154/article/details/109826279&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;高级数据结构与算法 | LFU缓存机制（Least Frequently Used）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;缓存常见问题&#34;&gt;缓存常见问题&lt;/h2&gt;
&lt;h3 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h3&gt;
&lt;p&gt;缓存雪崩指的是在短时间内，有大量缓存的键同时过期，由于缓存过期，导致此时所有的请求就直接查询数据库，而数据库很难抵挡这样巨大的压力，严重情况下就会导致数据库被大流量打死，直接宕机。&lt;/p&gt;
&lt;p&gt;下面是正常的查询流程以及缓存雪崩后的查询流程
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis76.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis77.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;缓存雪崩的解决方法有以下几种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;随机化过期时间&lt;/strong&gt;，为了避免缓存同时过期，在设置缓存时在原有时间上添加随机时间，使失效时间分散开来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加锁排队&lt;/strong&gt;，加锁排队可以起到缓冲的作用，防止大量请求同时操作数据库，但是也正因为如此也减少了吞吐量，导致响应时间变慢，用户体验变差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置二级缓存&lt;/strong&gt;，即加入一个本地缓存作为备案，当Redis缓存失效后就暂时使用本地缓存进行代替，避免直接访问数据库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置热点数据永不过期&lt;/strong&gt;，有更新操作时直接更新缓存即可&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h3&gt;
&lt;p&gt;缓存击穿与缓存雪崩很像，不过一个是针对大量缓存一个是针对热点缓存。&lt;/p&gt;
&lt;p&gt;缓存击穿即当某个热点缓存突然失效，而正好对其有着大量的请求，此时这些请求就会直接向数据库进行查询，导致数据库面临巨大的压力&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis78.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
缓存击穿的解决方法有以下几种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;设置热点数据永不过期&lt;/strong&gt;，有更新操作时直接更新缓存即可&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加锁排队&lt;/strong&gt;，通过加锁来减少同一时间的访问量，缓解压力&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h3&gt;
&lt;p&gt;缓存穿透是指查询的数据在缓存中和数据库中都不存在，此时请求就会直接绕过缓存抵达数据库，导致数据库压力过大。(由于主键通常都是从1开始自增，此时大量查询负数或者特别大的数据就会导致缓存穿透)。
出于容错考虑，由于这些数据在数据库中不存在，所以不会将结果保存到缓存中。而又因为缓存中没有这些数据，所以每次请求都会绕过缓存，直接向数据库查询，这就是缓存穿透。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis79.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
缓存穿透的解决方法有以下几种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;参数校验&lt;/strong&gt;，对于那些不合法的请求就直接返回空结果，不进行查询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布隆过滤器&lt;/strong&gt;，可以根据布隆过滤器来判断数据在不在数据库，虽然布隆过滤器查询存在不一定准确，但是如果布隆过滤器中查不到，则一定说明不存在，就不会进入数据库查询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存空结果&lt;/strong&gt;，将每次查询的结果进行缓存，即使查询不到的也缓存一个空结果，当有非法请求时就直接返回空结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓存预热&#34;&gt;缓存预热&lt;/h3&gt;
&lt;p&gt;与上面三种不同，&lt;strong&gt;缓存预热并不是一个需要解决的问题，而是一种优化的策略&lt;/strong&gt;，通过这种策略能够更快的响应用户的查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存预热指的是在启动系统的时候，提前将查询的结果预存到缓存中&lt;/strong&gt;，这样用户查询时就可以直接从缓存中读取，减少了用户的等待时间
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis80.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
缓存预热的实现方法有以下三种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;把需要缓存的函数写入到系统的构造函数中&lt;/strong&gt;，这样系统就会在启动的时候自动的加载数据并缓存数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把需要缓存的函数挂载到前端页面或者后端的接口上&lt;/strong&gt;，手动触发缓存预热&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置定时任务&lt;/strong&gt;，定时自动进行缓存预热&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Redis 持久化策略</title>
        <link>https://blog.orekilee.top/p/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</link>
        <pubDate>Thu, 26 May 2022 15:04:13 +0800</pubDate>
        
        <guid>https://blog.orekilee.top/p/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</guid>
        <description>&lt;h1 id=&#34;redis-持久化策略&#34;&gt;Redis 持久化策略&lt;/h1&gt;
&lt;h2 id=&#34;什么是持久化&#34;&gt;什么是持久化&lt;/h2&gt;
&lt;p&gt;由于内存具有易失性，无法进行断电存储，所以在重启之后数据就会丢失，但是硬盘具有永久存储的特性，所以&lt;strong&gt;持久化就是将数据从内存中保存到硬盘的过程&lt;/strong&gt;，&lt;strong&gt;目的就是为了防止数据的丢失&lt;/strong&gt;。
同时持久化也是Redis比起Memcached的优势，Memcached并不支持持久化&lt;/p&gt;
&lt;p&gt;Redis的持久化分为以下三种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RDB（Redis DataBase）持久化&lt;/li&gt;
&lt;li&gt;AOF（Append Only File）持久化&lt;/li&gt;
&lt;li&gt;混合持久化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;rdb持久化&#34;&gt;RDB持久化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RDB持久化其实就是以快照的方式进行持久化的存储。&lt;/strong&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis70.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对于一个Redis服务器来说，它的&lt;strong&gt;所有非空数据库&lt;/strong&gt;以及&lt;strong&gt;数据库中的所有键值对&lt;/strong&gt;就是当前数据库的&lt;strong&gt;状态&lt;/strong&gt;。所以只需要将数据库的状态保存在硬盘当中，即使服务器停机或者断电，只要硬盘中存储的状态还在，就可以通过它来还原数据库原来的状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis71.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis72.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
为了保证文件的安全以及容量更小，RDB持续化所生成的&lt;strong&gt;RDB文件是一个经过压缩的二进制文件&lt;/strong&gt;，通过这个文件就可以还原数据库的状态。&lt;/p&gt;
&lt;h3 id=&#34;sava与bgsava&#34;&gt;SAVA与BGSAVA&lt;/h3&gt;
&lt;p&gt;RDB持久化根据&lt;strong&gt;执行持久化的对象不同&lt;/strong&gt;又分为&lt;strong&gt;SAVA&lt;/strong&gt;和&lt;strong&gt;BGSAVA&lt;/strong&gt;两种方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SAVA即让Redis服务进程来执行持久化&lt;/strong&gt;，所以直到RDB持久化结束之前，Redis服务进程会一直处于阻塞状态，无法处理任何命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BGSAVE&lt;/strong&gt;则会通过fork()来创建一个子进程，然后&lt;strong&gt;让子进程来接管RDB持久化&lt;/strong&gt;，而父进程继续处理命令请求&lt;/p&gt;
&lt;p&gt;由于SAVA的会导致主进程的阻塞，所以使用时基本不会考虑，所以通常我们都会默认使用BGSAVA来进行，下面我指的也都是BGSAVA&lt;/p&gt;
&lt;h3 id=&#34;rdb持久化的优缺点&#34;&gt;RDB持久化的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB文件是经过压缩的二进制文件，占用内存更小更紧凑，适合作为备份文件&lt;/li&gt;
&lt;li&gt;RDB容灾恢复更有用，因为其更加紧凑，可以更快的传输到远程服务器进行数据恢复。&lt;/li&gt;
&lt;li&gt;RDB可以提高Redis的运行速度，因为使用BGSAVA持久化时会fork出子进程进行持久化的I/O操作，主进程不会受到干扰。&lt;/li&gt;
&lt;li&gt;比起AOF格式的文件，RDB文件这种直接恢复状态的重启更快
&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由于RDB是以快照形式进行保存的，并且快照之间存在一定的时间间隔，如果Redis服务被终止，则会导致丢失一段时间的数据&lt;/li&gt;
&lt;li&gt;RDB的BGSAVA需要fork()出子进程来进行持久化，但是如果CPU性能不佳且数据量很大的时候，fork()的时间就会增加，导致Redis可能会停止服务一段时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aof持久化&#34;&gt;AOF持久化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AOF持久化其实就是保存Redis服务器所执行的命令来保存数据库的状态&lt;/strong&gt;，将命令追加到AOF文件的末尾（Append Only File），&lt;strong&gt;AOF的核心其实就是将所有执行过的命令重新执行，来恢复状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么意思呢？例如我们执行了几条命令，此时AOF持久化会将这些命令以请求协议格式追加到AOF文件末尾
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis73.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
当服务器启动时，就会读取AOF文件中的所有命令，将其在服务器上重新执行一次，来恢复服务器的状态。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis74.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;aof重写&#34;&gt;AOF重写&lt;/h3&gt;
&lt;p&gt;随着服务器存储的数据越来越多，此时AOF保存的命令也越来越多，文件的体积就会变得非常大，这样就可能导致对Redis服务器以及宿主机造成影响，并且随着文件的增大，使用AOF来进行数据还原需要的时间也就更多。&lt;/p&gt;
&lt;p&gt;并且还存在一个问题，就是命令中存在着大量冗余和多余的命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lpush&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lpop&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;4&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rpop&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;5&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;例如上面这些命令，我存储了5 2 1 3 4五个数据，之后我又删除了4和5，所以最终剩下的只有1 2 3。
但是如果将所有的命令都保存进去，在恢复状态的时候又会重新模拟一次中间的删除流程，这些步骤是不需要的，我们只需要最终的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以AOF引入了重写的机制，即只保存能够获取最终结果的命令&lt;/strong&gt;
重写的流程很简单，就是去直接读取当前数据库中的键值状态，然后构造出对应的命令来进行保存
例如上面那个，就直接进行一次lpush 1 2 3，就可以直接省去了中间的操作。&lt;/p&gt;
&lt;p&gt;并且和RDB的BGSAVA一样，为了不阻塞主进程，&lt;strong&gt;所有的重写操作都会通过创建子进程来进行&lt;/strong&gt;，并且由于子进程创建时会通过写时拷贝机制带有服务器数据的副本，所以也不需要对数据进行加锁就可以保证安全，提高了效率
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis75.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
此时子进程进行AOF的重写，父进程则继续处理接受的请求。
但是这时又引入了一个问题，如果父进程接受了新的命令，这些命令可能就会对数据库的状态进行修改，这样就会导致&lt;strong&gt;重写后的AOF文件所保存的状态和当前的数据库状态不一致&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，&lt;strong&gt;服务器新增了一个AOF重写缓冲区&lt;/strong&gt;，将两个AOF的过程给分割开
&lt;strong&gt;服务器流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行客户端发送来的新命令&lt;/li&gt;
&lt;li&gt;将执行后的写命令追加到AOF缓冲区中&lt;/li&gt;
&lt;li&gt;将执行后的写命令追加到AOF重写缓冲区中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样AOF缓冲区的数据会被定期写入和同步到AOF文件中，不会影响整个AOF的流程。
而在执行重写后所执行的命令也都会保存到AOF重写缓冲区中。&lt;/p&gt;
&lt;p&gt;所以在子进程重写结束后，其会通过信号的方式来通知父进程，此时服务器就会进行以下的操作来完成重写的AOF文件的更换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将当前AOF重写缓冲区中的命令保存到一个新的AOF文件中，此时的新AOF文件的状态与当前数据库保存一致，并且比起旧的AOF更加简洁&lt;/li&gt;
&lt;li&gt;此时对新的AOF文件进行改名，原子性的覆盖掉原先的AOF文件，完成AOF重写文件与旧文件的更替&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aof持久化的优缺点&#34;&gt;AOF持久化的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF持久化保存的数据更加完整，其设定了三种保存策略：每次操作保存、每秒钟保存、跟随系统的持久化策略保存，其中每秒保存一次为AOF的默认策略。通过这种方法，使得即使发生了意外情况，最多也只会丢失1秒的数据，而不像RDB会丢失一段时间的数据&lt;/li&gt;
&lt;li&gt;AOF如其名，采用了命令追加的方式写入到文件中，所以不会出现文件损坏的问题&lt;/li&gt;
&lt;li&gt;AOF持久化将命令以协议格式写入文件，非常容易理解和解析，即使不小心使用&lt;strong&gt;flushall&lt;/strong&gt;进行删库，并且状态被保存了下来。也可以通过删除AOF文件中的flushall命令来消除那次操作。（RDB快照则没办法避免）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在数据量相同的时候，AOF文件要大于RDB文件&lt;/li&gt;
&lt;li&gt;在Redis负载较高的时候，RDB的性能比AOF更好&lt;/li&gt;
&lt;li&gt;RDB使用快照的形式来持久化整个Redis数据，而AOF是将每次执行的命令追加到AOF文件中，所以RDB比AOF更健壮&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;混合持久化&#34;&gt;混合持久化&lt;/h2&gt;
&lt;p&gt;混合持久化是在Redis4.0之后新增的一种方式，&lt;strong&gt;混合持久化结合了RDB和AOF的优点&lt;/strong&gt;，在写入文件的时候，&lt;strong&gt;会先把当前的数据以RDB的形式写入文件的开头&lt;/strong&gt;，&lt;strong&gt;再将后续的操作命令以AOF的格式写入文件中&lt;/strong&gt;，这样既能保证Redis重启时的速度（RDB快照状态恢复），又能减少数据丢失的风险（AOF丢失时间短）&lt;/p&gt;
&lt;h3 id=&#34;混合持久化的优缺点&#34;&gt;混合持久化的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结合了RDB和AOF的优点，开头为RDB格式的数据，可以快速启动（快照），并且之后为AOF格式，减少了大量数据丢失的风险
&lt;strong&gt;缺点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;AOF文件可读性变差，因为AOF文件前面增加了RDB格式的内容&lt;/li&gt;
&lt;li&gt;兼容性差，由于混合持久化是在4.0之后才引入的，如果开启之后则混合持久化AOF文件就不能使用在之前的版本&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis 数据类型</title>
        <link>https://blog.orekilee.top/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
        <pubDate>Thu, 26 May 2022 15:03:13 +0800</pubDate>
        
        <guid>https://blog.orekilee.top/p/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
        <description>&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;h2 id=&#34;基础数据类型&#34;&gt;基础数据类型&lt;/h2&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;p&gt;字符串类型（SDS）即简单动态字符串，它是以键值对key-value的形式进行存储的，根据 key 来存储和获取value值&lt;/p&gt;
&lt;p&gt;依据不同情况，字符串在底层会使用 &lt;strong&gt;int 、 raw 或者 embstr&lt;/strong&gt; 三种不同的编码格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数据为可以使用&lt;strong&gt;long类型&lt;/strong&gt;来保存的&lt;strong&gt;整数&lt;/strong&gt;，则使用&lt;strong&gt;int&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果数据为可以使用&lt;strong&gt;long double类型&lt;/strong&gt;来保存的&lt;strong&gt;浮点数&lt;/strong&gt;，则使用&lt;strong&gt;embstr或者raw&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果数据为字符串，或者长度过大没办法用long来表示的整数，以及长度过大无法用long double表示的浮点数，则使用&lt;strong&gt;embstr或者raw&lt;/strong&gt;。当数据小于39字节时，使用embstr，当大于39字节时使用raw
&lt;img src=&#34;http://img.orekilee.top//imgbed/distributed/redis50.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis51.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis52.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本用法&#34;&gt;基本用法&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;world&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;设置&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;OK&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;根据&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key获取value&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;计算&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value长度&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis53.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用场景&#34;&gt;使用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;存放用户（登录）信息；&lt;/li&gt;
&lt;li&gt;存放文章详情和列表信息；&lt;/li&gt;
&lt;li&gt;存放和累计网页的统计信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hash&#34;&gt;Hash&lt;/h3&gt;
&lt;p&gt;字典类型 (Hash) 又被成为散列类型或者是哈希表类型，它是将⼀个键值 (key) 和⼀个特殊的“哈希表”关联起来。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis54.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;哈希类型的底层数据结构可以是&lt;strong&gt;压缩列表&lt;/strong&gt;（ZipList)或者&lt;strong&gt;字典&lt;/strong&gt;（Dict）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当哈希对象的&lt;strong&gt;所有键值对的键和值的字符串长度都小于64字节&lt;/strong&gt;，并且&lt;strong&gt;保存的键值对数量小于512个&lt;/strong&gt;时，使用&lt;strong&gt;压缩列表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;不满足上述条件中的任意一个&lt;/strong&gt;，都会使用&lt;strong&gt;字典&lt;/strong&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis55.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis56.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis57.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本用法-1&#34;&gt;基本用法&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hset&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hash1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lee&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;设置&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value的映射&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hash1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;获取&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key为name的value&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;lee&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hash1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;获取&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key为age的value&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;20&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis58.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用场景-1&#34;&gt;使用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;存储用户信息或者某个物品的信息，无需序列化，直接建立映射&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;
&lt;p&gt;列表类型 (List) 是⼀个使用&lt;strong&gt;线性结构存储&lt;/strong&gt;的结构，它的元素插入会&lt;strong&gt;按照先后顺序&lt;/strong&gt;存储到链表结构中。 
列表类型的底层数据结构可以是&lt;strong&gt;压缩列表&lt;/strong&gt;（ZipList)或者&lt;strong&gt;链表&lt;/strong&gt;（LinkedList）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当列表对象的&lt;strong&gt;所有字符串元素长度都小于64字节&lt;/strong&gt;，并且&lt;strong&gt;保存的元素数量小于512个&lt;/strong&gt;时，使用&lt;strong&gt;压缩列表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;不满足上述条件中的任意一个&lt;/strong&gt;，都会使用&lt;strong&gt;链表&lt;/strong&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis59.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis60.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基本用法-2&#34;&gt;基本用法&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lpush&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;依次头插&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，此时数据为&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rpop&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;尾删&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lpop&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;头删&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;5&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis61.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用场景-2&#34;&gt;使用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第⼀个元素，所以列表类型可以用来实现消息队列；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文章列表&lt;/strong&gt;：对于博客站点来说，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样不仅可以完美的实现分页功能，而且加速了程序的响应速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;p&gt;集合类型 (Set) 是⼀个&lt;strong&gt;无序并唯⼀&lt;/strong&gt;的键值集合。&lt;/p&gt;
&lt;p&gt;集合类型的底层数据结构可以是&lt;strong&gt;整数集合&lt;/strong&gt;（IntSet)或者&lt;strong&gt;字典&lt;/strong&gt;（Dict）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当集合对象的&lt;strong&gt;所有元素都是整数值&lt;/strong&gt;，并且&lt;strong&gt;保存的元素数量小于512个&lt;/strong&gt;时，使用&lt;strong&gt;整数集合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;不满足上述条件中的任意一个&lt;/strong&gt;，都会使用&lt;strong&gt;字典&lt;/strong&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis62.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis63.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基本用法-3&#34;&gt;基本用法&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sadd&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;testSet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;smembers&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;testSet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;去重且无序&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;v2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;v4&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;v3&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis64.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用场景-3&#34;&gt;使用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;微博关注我的人和我关注的人都适合用集合存储，可以保证人员不会重复；&lt;/li&gt;
&lt;li&gt;中奖人信息也适合用集合类型存储，这样可以保证⼀个人不会重复中奖。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zset&#34;&gt;Zset&lt;/h3&gt;
&lt;p&gt;有序集合类型 (SortedSet) 相比于集合类型多了⼀个排序属性 &lt;strong&gt;score（分值）&lt;/strong&gt;，所以对于有序集合ZSet 来说，每个存储元素相当于有&lt;strong&gt;两个值&lt;/strong&gt;组成的，⼀个是有序结合的&lt;strong&gt;元素值&lt;/strong&gt;，⼀个是&lt;strong&gt;分值&lt;/strong&gt;。有序集合的存储&lt;strong&gt;元素值也是不能重复&lt;/strong&gt;的，但&lt;strong&gt;分值是可以重复&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;有序集合类型的底层数据结构可以是&lt;strong&gt;压缩列表&lt;/strong&gt;（ZipList)或者&lt;strong&gt;跳表&lt;/strong&gt;（SkipList ）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当有序集合对象的&lt;strong&gt;所有元素成员的长度都小于64字节&lt;/strong&gt;，并且&lt;strong&gt;保存的元素数量小于128个&lt;/strong&gt;时，使用&lt;strong&gt;压缩列表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;不满足上述条件中的任意一个&lt;/strong&gt;，都会使用&lt;strong&gt;跳表&lt;/strong&gt;（这里的跳表是结合字典的）
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis65.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis66.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;strong&gt;这里不是直接使用跳表，而是搭配字典一起使用&lt;/strong&gt;
之所以这样设置是因为考虑到如果直接使用跳跃表，如果需要查找成员的分值时只能通过遍历来进行查找，而这样的效率是O(logN)
而字典虽然建立映射后可以O(1)的查找到分值，但是哈希只能通过key值进行查找，并不支持范围查询。
所以将两者进行结合，使用字典建立起元素与分值的映射，&lt;strong&gt;使用字典来进行成员分数的查找&lt;/strong&gt;，而&lt;strong&gt;使用跳跃表来进行范围型操作&lt;/strong&gt;，这样就很好的解决了这个问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zset&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis67.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis68.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本用法-4&#34;&gt;基本用法&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zadd&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zset1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;插入时以分值&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;值的形式插入&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zrange&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zset1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;查找结果按照升序排序&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;v3&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;v4&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;v2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis69.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用场景-4&#34;&gt;使用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;学生成绩排名；&lt;/li&gt;
&lt;li&gt;粉丝列表，根据关注的先后时间排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;特殊数据类型&#34;&gt;特殊数据类型&lt;/h2&gt;
&lt;h3 id=&#34;geospatial地理空间&#34;&gt;Geospatial(地理空间)&lt;/h3&gt;
&lt;p&gt;在使用一些小程序的时候，里面通常都会通过定位使用者的位置，来显示附近的人、外卖距离、剩余路径等功能，在Redis3.2中也引入了推算地理信息的数据结构，即&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;Geospatial&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;
&lt;p&gt;把某个具体的位置信息（经度，纬度，名称）添加到指定的key中，数据将会用一个&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;sorted set&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;存储，以便稍后能使用 GEORADIUS和 GEORADIUSBYMEMBER命令来根据半径来查询位置信息。&lt;/p&gt;
&lt;p&gt;这个命令(指GEOADD)的参数使用标准的x,y形式，所以经度（longitude）必须放在纬度（latitude）之前，对于可被索引的坐标位置是有一定限制条件的：非常靠近极点的位置是不能被索引的， 在EPSG:900913 / EPSG:3785 / OSGEO:41001指定如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有效的经度是-180度到180度&lt;/li&gt;
&lt;li&gt;有效的纬度是-85.05112878度到85.05112878度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面是官方文档的描述，其实Geo并没有我们想象中的复杂，它的本质就是一个&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;Zset&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，通过将坐标以&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;Geohash&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;的方式进行处理，将经度纬度错位后形成一个52位整数，所以我们&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;同样能够使用Zset提供的接口来操作Geo&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;h4 id=&#34;用法&#34;&gt;用法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GEOADD key 经度 纬度 地点名称&lt;/td&gt;
&lt;td&gt;将指定的地理空间位置（经度、纬度、名称）添加到指定的key中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GEODIST key 地点1 地点2&lt;/td&gt;
&lt;td&gt;返回两个给定位置之间的距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GEOPOS key 地点&lt;/td&gt;
&lt;td&gt;从key里返回所有给定位置元素的位置（经度和纬度）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GEOHASH  key 地点&lt;/td&gt;
&lt;td&gt;返回一个或多个位置元素的 Geohash 表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GEORADIUS  key 经度 纬度 半径&lt;/td&gt;
&lt;td&gt;以给定的经纬度为中心， 找出某一半径内的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GEORADIUSBYMEMBER  key 地点 半径&lt;/td&gt;
&lt;td&gt;找出位于指定范围内的元素，中心点是由给定的位置元素决定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Zset的接口同样适用于Geo，因此需要删除、查询全部时就可以使用Zset的接口。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面示范一下这些命令的使用方式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 为了方便示范，下面加入一些城市的地理信息——GEOADD &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEOADD CHINA 108.94683  34.29296  &lt;span class=&#34;s2&#34;&gt;&amp;#34;xian&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEOADD CHINA 116.405285 39.904989 &lt;span class=&#34;s2&#34;&gt;&amp;#34;beijing&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEOADD CHINA 121.472644 31.231706 &lt;span class=&#34;s2&#34;&gt;&amp;#34;shanghai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEOADD CHINA 113.280637 23.125178 &lt;span class=&#34;s2&#34;&gt;&amp;#34;guangzhou&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEOADD CHINA 114.085947 22.547    &lt;span class=&#34;s2&#34;&gt;&amp;#34;shenzhen&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEOADD CHINA 110.33119  20.031971 &lt;span class=&#34;s2&#34;&gt;&amp;#34;hainan&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 获取北京和上海的距离——GEODIST &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEODIST CHINA beijing shanghai km
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;1067.5980&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 获取西安的坐标——GEOPOS &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEOPOS CHINA xian
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; 1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;108.94683212041854858&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   2&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;34.29296115814533863&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 以经度120 纬度35位置为中心，获取半径1000千米内的城市——GEORADIUS &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEORADIUS CHINA &lt;span class=&#34;m&#34;&gt;120&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;35&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1000&lt;/span&gt; km
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;beijing&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;shanghai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 获取在广州半径500千米内的城市——GEORADIUSBYMEMBER  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEORADIUSBYMEMBER CHINA guangzhou &lt;span class=&#34;m&#34;&gt;500&lt;/span&gt; km
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;shenzhen&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;guangzhou&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;hainan&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将广州和深圳的坐标转换为11为的GEO哈希值——GEOHASH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GEOHASH CHINA guangzhou shenzhen
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;ws0e9cb3yj0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;ws10k0dcg10&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;hyperloglog基数统计&#34;&gt;Hyperloglog(基数统计)&lt;/h3&gt;
&lt;p&gt;在我们为网站统计访问量、日活量时，由于我们统计的是用户数量而非访问次数，因此即使一个用户多次访问也只会统计一次，这种&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;不重复的数据&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;通常被称为&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;基数&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;p&gt;在传统的做法中，我们通常会采用set来保存用户的ID来进行计数，因为其本身存在着去重的功能，但是由于我们所需要的是对用户进行计数，如果通过将所有用户的ID保存的方法来完成，当用户量大的时候就会对内存产生巨大的压力，并且效率也大大降低。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，Redis在2.8.9版本添加了&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;HyperLogLog&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;结构。&lt;/p&gt;
&lt;h4 id=&#34;介绍-1&#34;&gt;介绍&lt;/h4&gt;
&lt;p&gt;Redis HyperLogLog是用来做&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;基数统计&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;的算法，HyperLogLog的优点是，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的&lt;/strong&gt;。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;在Redis 里面，每个HyperLogLog键只需要花费&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;12KB&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;内存，就可以计算接近&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;2^64&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。&lt;/p&gt;
&lt;p&gt;但是，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;由于HyperLogLog使用的是概率算法，通过存储元素的hash值的第一个1的位置，来计算元素数量&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，所以HyperLogLog &lt;!-- raw HTML omitted --&gt;&lt;strong&gt;不会存储元素本身&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，在数据量大的时候也可能会&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;存在一定的误差&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。但是在基数统计这一方面，它的效果是其他结构无法比拟的。&lt;/p&gt;
&lt;h4 id=&#34;用法-1&#34;&gt;用法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PFADD key value&lt;/td&gt;
&lt;td&gt;添加指定的值到Hyperloglog中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PFCONUT key&lt;/td&gt;
&lt;td&gt;返回给定Hyperloglog的基数估算值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PFMERGE destkey sourcekey&lt;/td&gt;
&lt;td&gt;将目标Hyperloglog合并到源Hyperloglog中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用示范&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; PFADD NUMS1 &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; 2	&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; 4	&lt;span class=&#34;c1&#34;&gt;#向NUMS1插入1-4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; PFADD NUMS1 1		&lt;span class=&#34;c1&#34;&gt;#数据已存在，不再插入&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; PFCOUNT NUMS1		&lt;span class=&#34;c1&#34;&gt;#查看当前基数数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; PFADD NUMS2 &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;5&lt;/span&gt; 6	&lt;span class=&#34;c1&#34;&gt;#向NUMS2插入3-6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; PFMERGE NUMS1 NUMS2	&lt;span class=&#34;c1&#34;&gt;#将NUMS2合并到NUMS1中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; PFCOUNT NUMS1		&lt;span class=&#34;c1&#34;&gt;#此时NUMS1中记录了1-6,六个元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; 6									
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;bitmap位图&#34;&gt;Bitmap(位图)&lt;/h3&gt;
&lt;h4 id=&#34;介绍-2&#34;&gt;介绍&lt;/h4&gt;
&lt;p&gt;位图其实就是哈希的变形，他通过哈希映射来处理数据，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;位图本身并不存储数据，而是存储标记&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。通过&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;一个比特位，即0/1来标记一个数据的两种状态&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;位图通常情况下用在数据量庞大，且数据不重复的情景下标记某个数据的两种状态。&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt; 我们可以使用位图来记录当前用户的登陆情况、或者实现打卡、签到等功能。&lt;/p&gt;
&lt;h4 id=&#34;用法-2&#34;&gt;用法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GETBIT key offset value(0/1)&lt;/td&gt;
&lt;td&gt;设置Bitmap中偏移量为offset的位置的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SETBIT key offset value&lt;/td&gt;
&lt;td&gt;返回Bitmap中偏移量为offset的位置的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BITCOUNT key&lt;/td&gt;
&lt;td&gt;计算位图中有多少个1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SETBIT TEST &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; 1	&lt;span class=&#34;c1&#34;&gt;#将位图中第1，3，5位设置为1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SETBIT TEST &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; SETBIT TEST &lt;span class=&#34;m&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GETBIT TEST &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; 	&lt;span class=&#34;c1&#34;&gt;#查看位图中1，2，3位的值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GETBIT TEST &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; GETBIT TEST &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127.0.0.1:6379&amp;gt; BITCOUNT TET	&lt;span class=&#34;c1&#34;&gt;#统计位图中1的数量，由于我们只设置了1，3，5位，因此为3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;integer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>Redis 数据结构</title>
        <link>https://blog.orekilee.top/p/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <pubDate>Thu, 26 May 2022 15:02:13 +0800</pubDate>
        
        <guid>https://blog.orekilee.top/p/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;h2 id=&#34;sds&#34;&gt;SDS&lt;/h2&gt;
&lt;h3 id=&#34;结构分析&#34;&gt;结构分析&lt;/h3&gt;
&lt;p&gt;由于C字符串存在大量问题，所以在Redis中，并没有使用C风格字符串，而是自己构建了一个简单动态字符串即SDS（simple dynamic string）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sdshdr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// buf 中已占用空间的长度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// buf 中剩余可用空间的长度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 数据空间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为解决C字符串缓冲区溢出问题以及长度计算问题，SDS中引入了len来统计当前已使用空间长度，free来计算剩余的空间长度&lt;/p&gt;
&lt;p&gt;C字符串的主要缺陷就是因为它没有记录自己的长度，而如果在需要了解长度时，就只能通过O（N）的效率进行一次遍历
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis5.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
并且因为C字符串没有统计剩余空间的字段，也没有容量字段，所以很容易就会因为strcat等函数造成缓冲区的溢出，为弥补这一缺陷，redis在sds中增加了free字段
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
通过标记剩余空间，当对SDS进行插入操作时，就会提前判断当前剩余空间是否足够，如果不足则会先进行空间的拓展，再进行插入，这样就解决了缓冲区溢出的问题&lt;/p&gt;
&lt;h3 id=&#34;内存策略&#34;&gt;内存策略&lt;/h3&gt;
&lt;p&gt;由于Redis作为一个高效的内存数据库，用于速度要求严苛，插入删除频繁
的场景，为了提高内存分配的效率，防止大量使用内存重分配而调用系统函数导致的性能损失问题（用户态和内核态的切换），Redis主要依靠&lt;strong&gt;空间预分配&lt;/strong&gt;和&lt;strong&gt;惰性空间释放来&lt;/strong&gt;解决这个问题&lt;/p&gt;
&lt;h4 id=&#34;空间预分配&#34;&gt;空间预分配&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;为减少空间分配的次数&lt;/strong&gt;，当需要进行空间拓展时，&lt;strong&gt;不仅仅会为SDS分配修改所必须要的空间，并且会为SDS预分配额外的未使用空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;预分配未使用空间的策略如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当SDS修改后的长度小于1MB时，将会预分配大小和当前len一样的空间(free = len)，也就是使空间增长一倍，来减少因为初始时申请大空间导致的连续分配问题&lt;/li&gt;
&lt;li&gt;当SDS修改后的长度大于等于1MB时，每次分配都会分配1MB的空间，防止空间的浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;惰性空间释放&#34;&gt;惰性空间释放&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;当我们对SDS进行删除操作时，并不会立即回收删除后空余的空间，而是将空余空间以free字段记录下来，以备后面使用。&lt;/strong&gt;
&lt;strong&gt;这样做的目的在于防止因为空间缩短后因为再度插入导致的空间拓展问题&lt;/strong&gt;。
并且如果有需求需要真正释放空间，Redis也提供了对应的API，所以不必担心会因为惰性的空间释放而导致的内存浪费问题。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;比起 C 字符串， SDS 具有以下优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常数复杂度获取字符串长度。（len字段）&lt;/li&gt;
&lt;li&gt;杜绝缓冲区溢出。（free字段）&lt;/li&gt;
&lt;li&gt;减少修改字符串长度时所需的内存重分配次数。（空间预分配，惰性空间释放）&lt;/li&gt;
&lt;li&gt;二进制安全。（以二进制形式处理）&lt;/li&gt;
&lt;li&gt;兼容部分 C 字符串函数。（底层基于C字符串，以空字符结尾）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;链表&#34;&gt;链表&lt;/h2&gt;
&lt;h3 id=&#34;结构分析-1&#34;&gt;结构分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 前置节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 后置节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 节点的值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * 双端链表迭代器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listIter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 当前迭代到的节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 迭代的方向
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;direction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listIter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * 双端链表结构
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 表头节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 表尾节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 节点值复制函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 节点值释放函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 节点值对比函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 链表所包含的节点数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
从上面的结构可以看出，Redis的链表是一个带头尾的双端无环链表，并且通过len字段记录了链表节点的长度
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;同时为了实现多态与泛型，链表中还提供了dup，free，match属性来设置相关的函数，使得链表支持不同类型的值的存储&lt;/p&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。&lt;/li&gt;
&lt;li&gt;每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。&lt;/li&gt;
&lt;li&gt;每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。&lt;/li&gt;
&lt;li&gt;因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。&lt;/li&gt;
&lt;li&gt;通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字典&#34;&gt;字典&lt;/h2&gt;
&lt;h3 id=&#34;结构分析-2&#34;&gt;结构分析&lt;/h3&gt;
&lt;p&gt;Redis的字典底层采用了哈希表来进行实现。&lt;/p&gt;
&lt;p&gt;首先看看字典底层哈希表的结构&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictht&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 哈希表数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 哈希表大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 哈希表大小掩码，用于计算索引值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 总是等于 size - 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sizemask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 该哈希表已有节点的数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;used&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictht&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
哈希表中记录了当前的总长度，已有节点，以及当前索引大小（用于哈希函数来计算节点位置)&lt;/p&gt;
&lt;p&gt;为解决哈希冲突，Redis字典采用了链地址法来构造了哈希桶的结构，也就是哈希数组中的每个元素都是一个链表。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis10.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;下面来看看哈希节点的结构&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 键
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 指向下个哈希表节点，形成链表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看到，为保证键值对适用于多重类型，key值使用的时void&lt;em&gt;的形式，而value使用了64位有符号整型和64位无符号整型，void&lt;/em&gt;指针的一个联合体，每个节点使用next来链接成一个链表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 计算哈希值的函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hashFunction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 复制键的函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyDup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 复制值的函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;valDup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 对比键的函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyCompare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 销毁键的函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyDestructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 销毁值的函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;valDestructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为保证字典具有多态及泛型，dictType中提供了如哈希函数以及K-V的各种操作函数，使得字典适用于多重情景&lt;/p&gt;
&lt;h3 id=&#34;rehash&#34;&gt;rehash&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * 字典
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 类型特定函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 私有数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 哈希表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;dictht&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ht&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// rehash 索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 当 rehash 不在进行时，值为 -1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rehashidx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* rehashing not in progress if rehashidx == -1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 目前正在运行的安全迭代器的数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iterators&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* number of iterators currently running */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;从字典的结构中，我们可以看到里面同时存放了两个哈希表，以及一个rehashidx属性。
这就牵扯到了字典的核心之一，rehash。&lt;/p&gt;
&lt;p&gt;Redis作为一个插入频繁且对效率要求高的数据库，当插入的数据过多时，就会因为哈希表中的负载因子过高而导致查询或者插入的效率降低，此时就需要通过rehash来进行重新扩容并重新映射。
但是如果只是用一个哈希表，映射时就会导致数据库暂时不可用，作为一个使用频繁的数据库，短期的停机几乎是不可容许的问题，所以Redis设计时采用了双哈希的结构，并采用了渐进式rehash的方法来解决这个问题。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis11.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rehash的步骤如下&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为ht[1]的哈希表分配空间&lt;/li&gt;
&lt;li&gt;将ht[0]中的键值对重新映射到ht[1]上&lt;/li&gt;
&lt;li&gt;当ht[0]的数据迁移完成，此时ht[0]为一个空表，此时释放ht[0]，并让ht[1]成为新的ht[0]，再为ht[1]创建一个新的空白哈希表，为下一次的rehash做准备
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis12.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis13.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis14.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;渐进式rehash&#34;&gt;渐进式rehash&lt;/h3&gt;
&lt;p&gt;由于数据库中可能存在大量的数据，而rehash的时候又过长，为了避免因为rehash造成的服务器停机，rehash的过程并不是一次完成的，而是一个多次的，渐进式的过程。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis15.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis16.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis17.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis18.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis19.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis20.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis21.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
在渐进式rehash的时候，由于数据不断的进行迁移，无法确定数据处于哪一个表上， 此时如果进行插入、删除、查找的操作时就会在两个表上进行，如果在一个表中没找到对应数据，就会到另一个表中继续查找。&lt;/p&gt;
&lt;p&gt;并且如果此时新插入节点，都会统一的防止在新表ht[1]中，防止对ht[0]的rehash造成干扰，保证ht[0]节点的只减少不增加&lt;/p&gt;
&lt;h3 id=&#34;总结-2&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。&lt;/li&gt;
&lt;li&gt;Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。&lt;/li&gt;
&lt;li&gt;当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。&lt;/li&gt;
&lt;li&gt;哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。&lt;/li&gt;
&lt;li&gt;在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;跳表&#34;&gt;跳表&lt;/h2&gt;
&lt;p&gt;跳表是一个较为少见的数据结构，如果不了解的可以看看我之前的博客
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_35423154/article/details/108477428&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;看了这篇博客，还敢说你不懂跳表吗？&lt;/a&gt;
由于跳表的实现简单且性能可与平衡树相媲美，对于大量插入删除的数据库来说，跳表只需要进行简单的链表插入和索引的选拔，而不像平衡树一样需要进行整体平衡的维持。并且由于在范围查找上的效率远远强于平衡树，所以Redis底层选取跳表来作为有序集合的底层之一。&lt;/p&gt;
&lt;h3 id=&#34;结构分析-3&#34;&gt;结构分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 成员对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 分值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 后退指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;backward&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 层
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistLevel&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 前进指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;forward&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 跨度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;跳跃表的查询从最顶层出发，通过前进指针来往后查找，通过比较节点的分数来判断当前节点是否与索引匹配，如果查找不到则进入下层继续查找，并记录下跨越的层数span来进行排位。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis22.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
同时为了处理特殊情况，还准备了一个后退指针来进行从表尾到表头的遍历，但是与前进不同，后退指针并不存在跳跃，而是只能一个一个向后查询
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis23.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * 跳跃表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 表头节点和表尾节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;header&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 表中节点的数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 表中层数最大的节点的层数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;跳跃表通过保存表头和表尾节点，来快速访问表头和表尾。并且保存了节点的数量来实现O(1)的长度计算
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis24.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
为了避免因为层数过高导致的大量空间损失，Redis跳跃表的节点高度最高位32层。&lt;/p&gt;
&lt;h3 id=&#34;总结-3&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。&lt;/li&gt;
&lt;li&gt;Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。&lt;/li&gt;
&lt;li&gt;每个跳跃表节点的层高都是 1 至 32 之间的随机数。&lt;/li&gt;
&lt;li&gt;在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。&lt;/li&gt;
&lt;li&gt;跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;整数集合&#34;&gt;整数集合&lt;/h2&gt;
&lt;p&gt;整数集合时集合键的底层实现之一，当集合中的元素全部都是整数值的时候，并且集合中元素不多时，Redis就会使用整数集合来作为集合键的底层结构。&lt;strong&gt;整数集合具有去重且排序的特性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;结构分析-4&#34;&gt;结构分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 编码方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 集合包含的元素数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 保存元素的数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;contents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在上面的结构中，虽然content数组的类型是一个8bit的整型，但是数据真正存储的方式并不是这个类型，而是根据encoding来决定具体的类型，8bit只是作为一个基本单位来进行使用。&lt;/p&gt;
&lt;p&gt;例如此时encoding设置为INTSET_ENC_INT16时，数组存储的格式就有每个元素16bit
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis25.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
如果encoding设置为INTSET_ENC_INT64时，数组存储的格式就有每个元素64bit
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis26.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;升级&#34;&gt;升级&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;升级的流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据插入的类型来决定集合升级的类型，拓展数组的整体空间并为新节点分配空间&lt;/li&gt;
&lt;li&gt;对集合中所有数据类型进行升级，在保持有序的前提下将所有升级后的元素移动到合适的位置上&lt;/li&gt;
&lt;li&gt;将新节点插入到集合的对应位置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;新元素的插入位置&lt;/strong&gt;
由于会引起升级的元素的类型都必顶比数组中的所有数据都大，所以也就决定了其要么比所有数据都大，要么比所有数据都小（负数），所以插入位置只能是首部和尾部&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当新元素比所有数据都大时在尾部插入&lt;/li&gt;
&lt;li&gt;当新元素比所有数据都小时在首部插入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis27.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis28.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
如果插入一个32位的数据，则引起全体升级&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis29.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;分配底层空间&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis30.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis31.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;整体升级并挪动位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis32.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;插入元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis33.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;降级&#34;&gt;降级&lt;/h3&gt;
&lt;p&gt;在整数列表中&lt;strong&gt;升级是一个不可逆的过程，即使将所有高类型的数据删除了，也不会进行降级。&lt;/strong&gt;
理由是防止因为降级后再次升级带来的大量数据挪动的问题，在保证了效率的同时，也带来了一定程度上的空间浪费（非必要时尽量不要升级）
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis34.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis35.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;strong&gt;升级带来的好处&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;灵活&lt;/strong&gt; ： 由于C语言是一个静态类型语言，为了避免出现类型错误通常会将不同类型分开，例如如果要存储16bit、32bit、64bit的整型就需要3个数组，但是使用整数集合就可以通过升级的策略来进行元素类型的自适应，就可以任意的将各种类型的整数插入进去，而不必担心类型错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节约内存&lt;/strong&gt;：与上面类似，如果我们只有一个64bit的数组，而里面存储了不少16bit、32bit的元素，则会造成空间的大量浪费。而使用整数集合则可以同时保存多个类型，只需要确保升级的操作只在必要时进行，就不会造成空间的浪费&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结-4&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;整数集合是集合键的底层实现之一。&lt;/li&gt;
&lt;li&gt;整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。&lt;/li&gt;
&lt;li&gt;升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。&lt;/li&gt;
&lt;li&gt;整数集合只支持升级操作， 不支持降级操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;压缩列表&#34;&gt;压缩列表&lt;/h2&gt;
&lt;p&gt;压缩列表（ziplist）是列表键和哈希键的底层实现之一。&lt;/p&gt;
&lt;p&gt;当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。&lt;strong&gt;主要核心就是为了节约空间&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;结构分析-5&#34;&gt;结构分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis36.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis37.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis38.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
例如这张图，可以看出当前包含三个节点，总空间为0x50(十进制80），到尾部的偏移量为0x3c(十进制60)，节点数量为0x3(十进制3)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis39.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;strong&gt;每个压缩列表节点可以由一个整数或者一个字节数组组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整数的类型可以是以下六种之一&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4位的介于0-12的无符号整数&lt;/li&gt;
&lt;li&gt;1字节的有符号整数&lt;/li&gt;
&lt;li&gt;3字节的有符号整数&lt;/li&gt;
&lt;li&gt;int16_t&lt;/li&gt;
&lt;li&gt;int32_t&lt;/li&gt;
&lt;li&gt;int64_t&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字节数组可以是以下三种之一&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长度小于等于63（2^6 -1)字节的字节数组&lt;/li&gt;
&lt;li&gt;长度小于等于16383（2^14 -1)字节的字节数组&lt;/li&gt;
&lt;li&gt;长度小于等于4294967295（2^32 -1)字节的字节数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而压缩列表节点又有三个属性组成，分别是previous_entry_length，encoding，content。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;previous_entry_length&lt;/strong&gt;
这个属性记录了压缩列表前一个节点的长度，该属性根据前一个节点的大小不同可以是1个字节或者5个字节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果前一个节点的长度小于254个字节，那么previous_entry_length的大小为1个字节，即前一个节点的长度可以使用1个字节表示&lt;/li&gt;
&lt;li&gt;如果前一个节点的长度大于等于254个字节，那么previous_entry_length的大小为5个字节，第一个字节会被设置为0xFE(十进制的254），之后的四个字节则用于保存前一个节点的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小于254字节时的表示
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis40.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
大于等于254字节时的表示
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis41.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;strong&gt;为什么要这样设计呢？&lt;/strong&gt;
由于压缩列表中的数据以一种不规则的方式进行紧邻，无法通过后退指针来找到上一个元素，而通过保存上一个节点的长度，用当前的地址减去这个长度，就可以很容易的获取到了上一个节点的位置，通过一个一个节点向前回溯，来达到从表尾往表头遍历的操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;encoding&lt;/strong&gt;
encoding通过以下规则来记录content的类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；&lt;/li&gt;
&lt;li&gt;一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis42.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;content&lt;/strong&gt;
&lt;strong&gt;content属性负责保存节点的值，值的具体类型由上一个字段encoding来决定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如存储字节数组，00表示类型为字节数组，01011表示长度为11
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis43.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
存储整数值，表示存储的为整数，类型为int16_t
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis44.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;连锁更新&#34;&gt;连锁更新&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当添加或删除节点时，可能就会因为previous_entry_length的变化导致发生连锁的更新操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis45.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
假设e1的previous_entry_length只有1个字节，而新插入的节点大小超过了254字节，此时由于e1
的previous_entry_length无法该长度，就会将previous_entry_length的长度更新为5字节。
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis46.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
但是问题来了，假设e1原本的大小为252字节，当previous_entry_length更新后它的大小则超过了254，此时又会引发对e2的更新。
顺着这个思路，一直更新下去
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis47.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis48.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
同理，删除也会引发连锁的更新
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis49.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
&gt;
从上图可以看出来，在最坏情况下，会从插入位置一直连锁更新到末尾，即执行了N次空间重分配， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。&lt;/p&gt;
&lt;p&gt;即使存在这种情况，但是并不影响我们使用压缩列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 这种情况就和连中彩票一样，很少见&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总结-5&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;压缩列表是一种为节约内存而开发的顺序型数据结构。&lt;/li&gt;
&lt;li&gt;压缩列表被用作列表键和哈希键的底层实现之一。&lt;/li&gt;
&lt;li&gt;压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。&lt;/li&gt;
&lt;li&gt;添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis 基本概念</title>
        <link>https://blog.orekilee.top/p/redis-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
        <pubDate>Thu, 26 May 2022 15:01:13 +0800</pubDate>
        
        <guid>https://blog.orekilee.top/p/redis-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
        <description>&lt;h1 id=&#34;redis-基本概念&#34;&gt;Redis 基本概念&lt;/h1&gt;
&lt;h2 id=&#34;什么是-redis&#34;&gt;什么是 Redis?&lt;/h2&gt;
&lt;p&gt;Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。它可以作为内存数据库、缓存和消息中间件，其中缓存是它最主要的使用场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;什么是缓存&#34;&gt;什么是缓存？&lt;/h2&gt;
&lt;h3 id=&#34;缓存概念&#34;&gt;缓存概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;缓存是⼀个高速数据交换的存储器，使用它可以快速的访问和操作数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个通俗的例子。
小明经营着一家饭店，在刚开张的时候由于名气不足，客源少，生意并不是很忙，平时没事的时候就闲着，有客人来了再进厨房安排做菜。随着饭店的日益发展，此时的饭店已经不同往日，有着大量的稳定客源，并且在某些节假日的时候甚至爆满。按照以前的做法，那肯定是行不通了，在用餐高峰期的时候因为备餐慢导致了客户的长时间等待，使得饭店的屡遭投诉。
为解决这一问题，小明想到了一个办法，&lt;strong&gt;可以在空闲的时候，提前将热门的菜做完后放入保温柜&lt;/strong&gt;，等用餐高峰期时再拿出来加热后就可以直接上菜，就规避了&lt;strong&gt;短时间内大量客源而导致的备餐慢的问题&lt;/strong&gt;，通过这一方法，即使在高峰期，也能很好的应对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就是缓存的本质，将热点资源（高频读、低频写）提前放入离用户最近、访问速度更快的地方，以提高访问速度。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;缓存-vs-数据库&#34;&gt;缓存 VS 数据库&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;相比于数据库而言，缓存的操作性能更高&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;缓存⼀般都是通过 key-value 查询数据&lt;/strong&gt;，因为不像数据库⼀样还有查询的条件等因素，所以查询的性能⼀般会比数据库高；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存的数据是存储在内存中的&lt;/strong&gt;，而数据库的数据是存储在磁盘中的，因为内存的操作性能远远大于磁盘，因此缓存的查询效率会高很多；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存更容易做分布式部署&lt;/strong&gt;（当⼀台服务器变成多台相连的服务器集群），而数据库⼀般比较难实现分布式部署，因此缓存的负载和性能更容易平行扩展和增加。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;本地缓存-vs-分布式缓存&#34;&gt;本地缓存 VS 分布式缓存&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;根据缓存是否与应用进程属于同一进程（单机与多机)，又分为本地缓存和分布式缓存&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;本地缓存&#34;&gt;本地缓存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本地缓存也叫做单机缓存，即将服务部署到一台服务器上，所以本地缓存只适用于当前系统&lt;/strong&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;举个例子，这个就如同每个学校的校规，&lt;strong&gt;根据学校的宗旨以教学理念不同，每个学校的校规都不一样&lt;/strong&gt;，对于A学校的学生来说，B学校的校规毫无意义，&lt;strong&gt;也就是说每个学校的校规只适用与那个学校&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以本地缓存只适用于当前系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问速度快，但无法进行大数据存储&lt;/li&gt;
&lt;li&gt;集群的数据更新问题&lt;/li&gt;
&lt;li&gt;数据随应用进程的重启而丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式缓存&#34;&gt;分布式缓存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;分布式缓存也叫做多机缓存，即将服务部署到多台服务器上，并且通过负载分发将用户的请求按照⼀定的规则分发到不同服务器。&lt;/strong&gt;
&lt;img src=&#34;http://img.orekilee.top//imgbed/redis/redis3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;而分布式缓存就如同教育局定下来的教学规范，无论是任何学校都必须遵守这个规范。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以分布式缓存适用与所有的系统。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持大数据量存储，不受应用进程重启影响&lt;/li&gt;
&lt;li&gt;数据集中存储，保证数据一致性&lt;/li&gt;
&lt;li&gt;数据读写分离，高性能，高可用&lt;/li&gt;
&lt;li&gt;数据跨网络传输，性能低于本地缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;memcached-vs-redis&#34;&gt;Memcached VS Redis&lt;/h2&gt;
&lt;p&gt;在市面上流行的分布式缓存中间件有两种，分别是&lt;strong&gt;Redis和Memcached&lt;/strong&gt;，我们该如何对他们进行一个选择呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Memcached把所有数据存在内存当中，数据大小不能超过内存大小，并且断电后数据会丢失。（不支持持久化，导致容灾能力弱）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis有部分存储在硬盘中，保证了数据的持久性。（持久化策略）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Memcached对数据类型的支持较为简单，有时需要将数据拿到客户端来进行类似的修改再set回去，增加了网络IO的次数和数据体积&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis具有复杂的数据类型，并且这些复杂类型的操作和get/set一样高效&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储值大小&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redis最大可以达到512mb&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memcached最大只有1mb&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redis使用单核，在存储小数据时Redis有着明显的优势&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memcached使用多核，虽然在存储小数据的时候性能不及Redis，但是在存储大数据的时候Memcached要远远强于Redis&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然从上面的结论以及当前流行程度来看，Redis都遥遥领先，但是在某些场景下，Memcached的作用也会高于Redis(例如海量数据查询），所以还需要根据具体使用场景来进行选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redis除了作为NoSQL数据库使用外，还能用做消息队列、数据堆栈和数据缓存等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
